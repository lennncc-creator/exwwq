# -*- coding: utf-8 -*-
from __future__ import annotations


import asyncio
import json
import os
import html
import re
import time
from aiogram.types import InputMediaPhoto
from aiogram.enums import ParseMode

from dataclasses import dataclass
from datetime import datetime, timedelta, timezone
from typing import Dict, List, Optional, Tuple
from db import (
    get_user, add_user, update_user_lang, get_all_users,
    add_category, get_categories, find_category, delete_category,
    add_script, get_scripts, find_script, delete_script
)
from scriptblox_api import api_trending, api_search, format_script_caption, extract_image_url


import aiohttp

from aiogram.types import BotCommand
from asyncio import Semaphore
from aiogram import Bot, Dispatcher, F
from aiogram.enums import ParseMode
from aiogram.filters import StateFilter
from aiogram.filters import Command, CommandStart
from aiogram.fsm.context import FSMContext
from urllib.parse import urlparse
from aiogram.fsm.state import State, StatesGroup
from aiogram.types import (
    CallbackQuery,
    InlineKeyboardButton,
    InlineKeyboardMarkup,
    Message,
    InputMediaPhoto,
)
from aiogram.utils.keyboard import InlineKeyboardBuilder
from aiogram.client.default import DefaultBotProperties

# ========================= CONFIG =========================




TOKEN = "8412358762:AAFpsJV3RXCl1P10YghrKd7wznKk4alXTTA"
ADMIN_IDS = {7700558902, 1154554868, 1190117295, 7701801337}
BOT_USERNAME = "MagicRBX_bot"

DATA_DIR = "data"
USERS_FILE = os.path.join(DATA_DIR, "users.json")
CATALOG_FILE = os.path.join(DATA_DIR, "catalog.json")

# –ï–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω—ã–π –∫–∞–Ω–∞–ª –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–æ–¥–ø–∏—Å–∫–∏
CHANNELS = []

# –ü–æ–∫–∞–∑–∞—Ç—å debug-–∫–Ω–æ–ø–∫—É ¬´–ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫–∏¬ª (—É–±–µ—Ä–∏—Ç–µ –ø–µ—Ä–µ–¥ —Ä–µ–ª–∏–∑–æ–º)
DEBUG_SKIP_SUBS = True

# –ê–Ω—Ç–∏—Å–ø–∞–º –Ω–∞ –ø–µ—Ä–µ–ª–∏—Å—Ç—ã–≤–∞–Ω–∏–µ –∫–∞—Ä—Ç–æ—á–µ–∫ (—Å–µ–∫)
SWIPE_COOLDOWN = 10

FORCE_SUBS_ENABLED = True

SUBGRAM_API_KEY = "7c36290afdecc4fd2af4e3eed3853e6f6b4673527c77f2237015492e256c1210"
SUBGRAM_BASE_URL = "https://subgram.ru/api"
SUBGRAM_CACHE_TTL = 30  # –∫—ç—à–∏—Ä—É–µ–º –æ—Ç–≤–µ—Ç—ã API –Ω–∞ 30 —Å–µ–∫, —á—Ç–æ–±—ã –Ω–µ –¥–æ–ª–±–∏—Ç—å






# ========================= –ö–ê–†–¢–ò–ù–ö–ò =========================
IMAGES = {
    "bypass": "https://i.postimg.cc/65M9DZzx/bypass.png",       # –ù–∞—á–∞—Ç—å –±–∞–π–ø–∞—Å—Å —Å—Å—ã–ª–æ–∫
    "catalog": "https://i.postimg.cc/bwnBQcZV/catalog.png",     # –ö–∞—Ç–∞–ª–æ–≥
    "loading": "https://i.postimg.cc/rpLYjnWV/loading.png",     # –≠–∫—Ä–∞–Ω "–ó–∞–≥—Ä—É–∑–∫–∞ —Å–∫—Ä–∏–ø—Ç–æ–≤"
    "menu": "https://i.postimg.cc/T1PsmKbn/menu.png",           # –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é
    "profile": "https://i.postimg.cc/4Nq07Nxh/profile.png",     # –ü—Ä–æ—Ñ–∏–ª—å
    "scripts": "https://i.postimg.cc/q7LQLk4w/scriptss.png",    # –ú–µ–Ω—é —Å–∫—Ä–∏–ø—Ç–æ–≤ –≤ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
    "subscription": "https://i.postimg.cc/269ws2qB/subs.png",   # –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–¥–ø–∏—Å–∫–∏
    "trends": "https://i.postimg.cc/rsdJMxWZ/trends.png",       # –¢—Ä–µ–Ω–¥—ã
    "search": "https://i.postimg.cc/pVwkbSDw/Search.jpg",       # search
    "settings": "https://i.postimg.cc/7h2VJ1yt/settings.jpg",   # settings
    "bypassed": "https://i.postimg.cc/7b8VKRny/bypassed.png"    # bypassed
}


# ========================= –î–ï–§–û–õ–¢ –ö–û–ú–ê–ù–î–´ –ò–ó –ú–ï–ù–Æ =========================

async def set_commands(bot: Bot):
    commands = [
        BotCommand(command="start", description="‚ö° –ó–∞–ø—É—Å—Ç–∏—Ç—å –ë–æ—Ç–∞"),
        BotCommand(command="menu", description="üíé –û—Ç–∫—Ä—ã—Ç—å –ú–µ–Ω—é"),
        BotCommand(command="catalog", description="üåê –û—Ç–∫—Ä—ã—Ç—å –ö–∞—Ç–∞–ª–æ–≥")
    ]
    await bot.set_my_commands(commands)



# ========================= –ö–≠–® –¢–†–ï–ù–î–û–í =========================

TREND_CACHE = {"data": None, "time": None}
TREND_TTL = 600  # 10 –º–∏–Ω—É—Ç

async def get_trends_cached():
    now = datetime.now(timezone.utc)
    if TREND_CACHE["data"] and TREND_CACHE["time"] and (now - TREND_CACHE["time"]).total_seconds() < TREND_TTL:
        return TREND_CACHE["data"]

    items = await api_trending()
    if items:
        TREND_CACHE["data"] = items
        TREND_CACHE["time"] = now
    return items



# ========================= –õ–û–ö–ê–õ–ò =========================
RU = {
    "welcome_title": "üëã –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ ExodusRBX_bot üöÄ",
    "menu_start_bypass": "ü™Ñ –ù–∞—á–∞—Ç—å –±–∞–π–ø–∞—Å—Å —Å—Å—ã–ª–æ–∫",
    "menu_catalog": "üóÇ –ö–∞—Ç–∞–ª–æ–≥ —Å–∫—Ä–∏–ø—Ç–æ–≤",
    "menu_search": "üîç –ü–æ–∏—Å–∫ —Å–∫—Ä–∏–ø—Ç–æ–≤",
    "menu_services": "‚ö° –ê–∫—Ç—É–∞–ª—å–Ω—ã–µ –ò–Ω–∂–µ–∫—Ç–æ—Ä—ã",
    "menu_settings": "‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏",
    "menu_profile": "üë§ –ü—Ä–æ—Ñ–∏–ª—å",
    "back": "‚¨ÖÔ∏è –ù–∞–∑–∞–¥",
    "choose_category": "üóÇ –í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—é:",
    "scripts_in_cat": "üìú –°–∫—Ä–∏–ø—Ç—ã –≤ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ ¬´{name}¬ª:",
    "share": "üîó –ü–æ–¥–µ–ª–∏—Ç—å—Å—è",
    "subscription_required": "üöÄ –ë–æ–ª—å—à–µ –Ω–µ –Ω—É–∂–Ω–æ —Ç—Ä–∞—Ç–∏—Ç—å –≤—Ä–µ–º—è –Ω–∞ –ª–∏—à–Ω–∏–µ –∫–ª–∏–∫–∏ ‚Äî –æ–±—Ö–æ–¥–∏—Ç–µ —Å—Å—ã–ª–∫–∏ –≤ –ø–∞—Ä—É —Å–µ–∫—É–Ω–¥.\n\nüóÇ –í—Å–µ –Ω—É–∂–Ω—ã–µ —Å–∫—Ä–∏–ø—Ç—ã —Å–æ–±—Ä–∞–Ω—ã –≤ –æ–¥–Ω–æ–º –º–µ—Å—Ç–µ ‚Äî –ø–æ—Å–º–æ—Ç—Ä–∏—Ç–µ –Ω–∞—à <b>–ö–∞—Ç–∞–ª–æ–≥</b>.\n\nüîç –ù–µ—Ç –Ω—É–∂–Ω–æ–≥–æ –ø–ª–µ–π—Å–∞? ‚Äî –ø–æ –∫–Ω–æ–ø–∫–µ <b>–ü–æ–∏—Å–∫</b> –º—ã –Ω–∞–π–¥—ë–º –ª—É—á—à–∏–µ —Å–∫—Ä–∏–ø—Ç—ã –Ω–∞ –≤–∞—à –≤–∫—É—Å!\n\n‚ö° –ù–∞—á–Ω–∏—Ç–µ –ø—Ä—è–º–æ —Å–µ–π—á–∞—Å: –≤—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ –≤ –º–µ–Ω—é –Ω–∏–∂–µ.",
    "sub_check_title": "üì¢<b> –ü–æ–¥–ø–∏—à–∏—Ç–µ—Å—å –Ω–∞ –∫–∞–Ω–∞–ª—ã, —á—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø –∫:</b>\n\nüöÄ <b>–ë—ã—Å—Ç—Ä–æ–º—É –∏ —É–¥–æ–±–Ω–æ–º—É –æ–±—Ö–æ–¥—É —Å—Å—ã–ª–æ–∫</b> –±–µ–∑ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π\n\nüóÇ <b>–ü–æ–ª–Ω–æ–º—É –∫–∞—Ç–∞–ª–æ–≥—É</b> —Å–∫—Ä–∏–ø—Ç–æ–≤ –≤ –æ–¥–Ω–æ–º –º–µ—Å—Ç–µ\n\nüîç <b>–†–∞—Å—à–∏—Ä–µ–Ω–Ω–æ–º—É –ø–æ–∏—Å–∫—É</b> —Å–∫—Ä–∏–ø—Ç–æ–≤ –ø–æ–¥ –ª—é–±–æ–π –ø–ª–µ–π—Å\n\n –ü–æ—Å–ª–µ –ø–æ–¥–ø–∏—Å–∫–∏ –Ω–∞–∂–º–∏—Ç–µ ‚úÖ <b>¬´–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É¬ª</b> –∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –±–æ—Ç–∞ –Ω–∞ –ø–æ–ª–Ω—É—é!",

    "check_sub": "‚úÖ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É",
    "skip_debug": "üîß –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å (debug)",
    "sub_ok": "üéâ –°–ø–∞—Å–∏–±–æ! –ü–æ–¥–ø–∏—Å–∫–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞.",
    "lang": "üåê –Ø–∑—ã–∫",
    "lang_ru": "üá∑üá∫ –†—É—Å—Å–∫–∏–π",
    "lang_en": "üá∫üá∏ English",
    "change_lang": "‚ùì –í—ã–±–µ—Ä–∏—Ç–µ —è–∑—ã–∫ –±–æ—Ç–∞:",
    "settings_title": "‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏",
    "no_items": "‚ùå –ü–æ–∫–∞ –Ω–∏—á–µ–≥–æ –Ω–µ—Ç.",
    "script_added": "‚úÖ –°–∫—Ä–∏–ø—Ç –¥–æ–±–∞–≤–ª–µ–Ω.",
    "category_added": "üóÇ –ö–∞—Ç–µ–≥–æ—Ä–∏—è –¥–æ–±–∞–≤–ª–µ–Ω–∞.",
    "deleted": "üóëÔ∏è –£–¥–∞–ª–µ–Ω–æ.",
    "are_you_sure_delete_cat": "‚ö†Ô∏è –¢–æ—á–Ω–æ —É–¥–∞–ª–∏—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é ¬´{name}¬ª?",
    "are_you_sure_delete_script": "‚ö†Ô∏è –¢–æ—á–Ω–æ —É–¥–∞–ª–∏—Ç—å —Å–∫—Ä–∏–ø—Ç ¬´{name}¬ª?",
    "stats_title": "üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π",
    "stats_total": "üë• –í—Å–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: {n}",
    "stats_today": "üìÖ –ó–∞ —Å–µ–≥–æ–¥–Ω—è: {n}",
    "stats_week": "üìÜ –ó–∞ 7 –¥–Ω–µ–π: {n}",
    # Search submenu
    "search_menu_title": "üîç –ü–æ–∏—Å–∫ —Å–∫—Ä–∏–ø—Ç–æ–≤",
    "search_btn_new": " üîç –ù–æ–≤—ã–π –ø–æ–∏—Å–∫",
    "search_btn_trends": "üåü –¢—Ä–µ–Ω–¥—ã",
    "search_enter_mode": "üéÆ –ö–∞–∫–∏–µ —Å–∫—Ä–∏–ø—Ç—ã –≤—ã —Ö–æ—Ç–∏—Ç–µ —É–≤–∏–¥–µ—Ç—å?",
    "search_mode_any": "‚ú® –õ—é–±—ã–µ",
    "search_mode_free": "üíé –ë–µ—Å–ø–ª–∞—Ç–Ω—ã–µ",
    "search_mode_paid": "üí∞ –ü–ª–∞—Ç–Ω—ã–µ",
    "search_enter_query": "‚å®Ô∏è –í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –∏–≥—Ä—ã/—Ä–µ–∂–∏–º–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä: \"Grow a Garden\"):",
    "search_no_results": "‚ùå –ù–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –ø–æ –∑–∞–ø—Ä–æ—Å—É ¬´{q}¬ª. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –¥—Ä—É–≥–æ–π –∑–∞–ø—Ä–æ—Å.",
    "search_loading": "‚è≥ –ò—â—É –ª—É—á—à–∏–µ —Å–∫—Ä–∏–ø—Ç—ã –¥–ª—è –í–∞—Å...",
    "search_back": "‚¨ÖÔ∏è –ù–∞–∑–∞–¥",
    # Trends
    "trends_title": "üåü –¢—Ä–µ–Ω–¥—ã ScriptBlox (—Ç–æ–ø 10)",
    "trends_back": "‚¨ÖÔ∏è –ù–∞–∑–∞–¥",
    # Swipe
    "swipe_on_cooldown": "‚è≥ –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–¥–æ–∂–¥–∏—Ç–µ {sec} —Å–µ–∫ –ø–µ—Ä–µ–¥ —Å–ª–µ–¥—É—é—â–µ–π –Ω–∞–≤–∏–≥–∞—Ü–∏–µ–π.",
}


EN = {
    "welcome_title": "üéâ Welcome to ExodusRBX_Bot!",
    "menu_start_bypass": "üîó Start bypassing links",
    "menu_catalog": "üìú Scripts catalog",
    "menu_search": "üîç Search scripts",
    "menu_services": "üõ†Ô∏è Injectors",
    "menu_settings": "‚öôÔ∏è Settings",
    "menu_profile": "üë§ Profile",
    "back": "‚¨ÖÔ∏è Back",
    "choose_category": "üóÇÔ∏è Choose a category:",
    "scripts_in_cat": "üìÑ Scripts in '{name}':",
    "share": "üì§ Share",
    "subscription_required": "‚ú® Please subscribe to the channels below and press \"Check subscription\".",
    "sub_check_title": "‚ú® Please subscribe to the channels below and press \"Check subscription\".",
    "check_sub": "‚úÖ Check subscription",
    "skip_debug": "üîß Skip (debug)",
    "sub_ok": "üôå Thanks! Subscription confirmed.",
    "lang": "üåê Language",
    "lang_ru": "üá∑üá∫ –†—É—Å—Å–∫–∏–π",
    "lang_en": "üá¨üáß English",
    "change_lang": "üó£Ô∏è Choose language:",
    "settings_title": "‚öôÔ∏è Settings",
    "no_items": "üòÖ Nothing here yet.",
    "script_added": "‚ûï Script added.",
    "category_added": "‚ûï Category added.",
    "deleted": "üóëÔ∏è Deleted.",
    "are_you_sure_delete_cat": "‚ùå Delete category \"{name}\"?",
    "are_you_sure_delete_script": "‚ùå Delete script \"{name}\"?",
    "stats_title": "üìä User statistics",
    "stats_total": "üë• Total users: {n}",
    "stats_today": "üìÖ Today: {n}",
    "stats_week": "üìÜ Last 7 days: {n}",
    "search_menu_title": "üîé Search scripts",
    "search_btn_new": "üîç New search",
    "search_btn_trends": "üåü Trends",
    "search_enter_mode": "‚ö° What kind of mode? Choose below or skip.",
    "search_mode_any": "üé≤ Any",
    "search_mode_free": "üí∏ Free",
    "search_mode_paid": "üí∞ Paid",
    "search_enter_query": "üéÆ Enter game/mode name (e.g. \"Grow a Garden\"):",
    "search_no_results": "üòï No results for ‚Äú{q}‚Äù. Try another query.",
    "search_loading": "‚è≥ Searching...",
    "search_back": "‚¨ÖÔ∏è Back",
    "trends_title": "üî• Trending ScriptBlox (top 10)",
    "trends_back": "‚¨ÖÔ∏è Back",
    "swipe_on_cooldown": "‚è±Ô∏è Please wait {sec} sec before next.",
}


LOCALES = {"ru": RU, "en": EN}
DEFAULT_LANG = "ru"

# ========================= –ú–û–î–ï–õ–ò –î–ê–ù–ù–´–• =========================
@dataclass
class Script:
    id: int
    name: str
    description: str

@dataclass
class Category:
    id: int
    name: str
    scripts: List[Script]

# ========================= –£–¢–ò–õ–ò–¢–´ –•–†–ê–ù–ò–õ–ò–©–ê =========================


# ========================= –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–û–ï UI =========================

def t(user_id: int, key: str, **fmt) -> str:
    user = get_user(user_id)
    lang = user["lang"] if user else DEFAULT_LANG   # 0=id, 1=lang, 2=joined
    return LOCALES.get(lang, RU)[key].format(**fmt)


def menu_keyboard(user_id: int) -> InlineKeyboardMarkup:
    user = get_user(user_id)
    lang = user["lang"] if user else DEFAULT_LANG  # 0=id, 1=lang, 2=joined
    L = LOCALES.get(lang, RU)

    kb = InlineKeyboardBuilder()
    kb.button(text=L["menu_start_bypass"], callback_data="menu:bypass")
    kb.button(text=L["menu_catalog"], callback_data="menu:catalog")
    kb.button(text=L["menu_search"], callback_data="menu:search")
    kb.button(text=L["menu_services"], callback_data="menu:services")
    kb.button(text=L["menu_settings"], callback_data="menu:settings")
    kb.button(text=L["menu_profile"], callback_data="menu:profile")

    kb.adjust(1, 2, 2, 1)
    return kb.as_markup()

def back_kb(user_id: int, where: str) -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(inline_keyboard=[[InlineKeyboardButton(text=t(user_id, "back"), callback_data=where)]])

def categories_keyboard(user_id: int, cats: list[dict]) -> InlineKeyboardMarkup:
    kb = InlineKeyboardBuilder()
    for c in cats:
        kb.button(text=c["name"], callback_data=f"cat:{c['id']}")
    kb.button(text=t(user_id, "back"), callback_data="menu:root")
    kb.adjust(1)
    return kb.as_markup()


def scripts_keyboard(user_id: int, cat: dict, scripts: list[dict]) -> InlineKeyboardMarkup:
    kb = InlineKeyboardBuilder()
    for s in scripts:
        kb.button(text=s["name"], callback_data=f"script:{cat['id']}:{s['id']}")
    kb.button(text=t(user_id, "back"), callback_data="catalog:root")
    kb.adjust(1)
    return kb.as_markup()


def script_card_kb(user_id: int, cat_id: int, script_id: int) -> InlineKeyboardMarkup:
    deep = f"https://t.me/{BOT_USERNAME}?start=idc{cat_id}ids{script_id}"
    kb = InlineKeyboardBuilder()
    kb.button(text=t(user_id, "share"), url=deep)
    kb.button(text=t(user_id, "back"), callback_data=f"cat:{cat_id}")
    kb.adjust(2)
    return kb.as_markup()

# ========================= –ü–†–û–í–ï–†–ö–ê –ü–û–î–ü–ò–°–ö–ò (–æ–¥–∏–Ω –∫–∞–Ω–∞–ª) =========================

# ========================= –ü–†–û–í–ï–†–ö–ê –ü–û–î–ü–ò–°–û–ö =========================

async def check_subscription(user_id: int, bot: Bot, channel_id: int) -> bool:
    if not CHANNELS:  # –µ—Å–ª–∏ —Å–ø–∏—Å–æ–∫ –ø—É—Å—Ç–æ–π ‚Äî –≤—Å–µ–≥–¥–∞ "–ø–æ–¥–ø–∏—Å–∞–Ω"
        return True
    try:
        member = await bot.get_chat_member(channel_id, user_id)
        return member.status in ("member", "administrator", "creator")
    except Exception:
        return False


async def get_subscription_keyboard(user_id: int, bot: Bot):
    kb = InlineKeyboardBuilder()

    if not CHANNELS:  # –µ—Å–ª–∏ –Ω–µ—Ç –∫–∞–Ω–∞–ª–æ–≤, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –ø—É—Å—Ç—É—é –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É
        return None

    # –î–æ–±–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ —Ç–µ –∫–∞–Ω–∞–ª—ã, –Ω–∞ –∫–æ—Ç–æ—Ä—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –ù–ï –ø–æ–¥–ø–∏—Å–∞–Ω
    for ch in CHANNELS:
        if not await check_subscription(user_id, bot, ch["id"]):
            kb.button(text=ch["title"], url=ch["link"])

    if kb.buttons:
        kb.button(text="‚úÖ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É", callback_data="subs:check")

    kb.adjust(1)
    return kb.as_markup()




async def ensure_subscribed(
    message: Message | CallbackQuery,
    state: FSMContext,
    target: Optional[Tuple[int, int]] = None
) -> bool:
    """–ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–¥–ø–∏—Å–∫–∏ –Ω–∞ –≤—Å–µ –∫–∞–Ω–∞–ª—ã. –ï—Å–ª–∏ –Ω–µ –ø–æ–¥–ø–∏—Å–∞–Ω ‚Äî –≤—ã–≤–æ–¥–∏—Ç –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É –ø–æ–¥–ø–∏—Å–∫–∏."""
    
    # üîπ –ï—Å–ª–∏ —Å–ø–∏—Å–æ–∫ –∫–∞–Ω–∞–ª–æ–≤ –ø—É—Å—Ç–æ–π ‚Üí –ø–æ–¥–ø–∏—Å–∫–∞ –Ω–µ —Ç—Ä–µ–±—É–µ—Ç—Å—è
    if not CHANNELS:
        return True

    bot = message.bot if isinstance(message, Message) else message.message.bot
    user_id = message.from_user.id

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤—Å–µ –∫–∞–Ω–∞–ª—ã
    unsubscribed = [
        ch for ch in CHANNELS if not await check_subscription(user_id, bot, ch["id"])
    ]

    if not unsubscribed:  # –µ—Å–ª–∏ –≤—Å—ë –æ–∫
        return True

    # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ü–µ–ª—å (–µ—Å–ª–∏ deep-link –≤ —Å–∫—Ä–∏–ø—Ç)
    if target:
        await state.update_data(pending_target={"cat": target[0], "script": target[1]})

    text = t(user_id, "sub_check_title")

    if isinstance(message, Message):
        await message.answer_photo(
            photo=IMAGES["subscription"],
            caption=text,
            reply_markup=await get_subscription_keyboard(user_id, bot)
        )
    else:
        await message.message.answer_photo(
            photo=IMAGES["subscription"],
            caption=text,
            reply_markup=await get_subscription_keyboard(user_id, bot)
        )

    return False



# ========================= FSM –¥–ª—è –∞–¥–º–∏–Ω–∫–∏ –∏ –ø–æ–∏—Å–∫–∞ =========================
class SendStates(StatesGroup):
    waiting_message = State()

class EditMode(StatesGroup):
    choose_entity = State()

class EditCategories(StatesGroup):
    choose_action = State()
    waiting_new_name = State()
    confirm_delete = State()

class EditScripts(StatesGroup):
    choose_action = State()
    choose_cat = State()
    waiting_script_name = State()
    waiting_script_desc = State()
    choose_cat_delete = State()
    choose_script_delete = State()
    confirm_delete = State()

class SearchFSM(StatesGroup):
    choose_mode = State()
    waiting_query = State()
    showing_results = State()

class BypassFSM(StatesGroup):
    waiting_url = State()

def bypass_back_kb(user_id: int):
    kb = InlineKeyboardBuilder()
    kb.button(text=t(user_id, "back"), callback_data="menu:root")  # –Ω–∞–∑–∞–¥ –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é
    return kb.as_markup()

# ========================= –í–†–ï–ú–ï–ù–ù–´–ï –ö–ï–®–ò (–≤ –ø–∞–º—è—Ç–∏) =========================
SEARCH_CACHE: Dict[int, dict] = {}  # user_id -> {"results": [...], "index": 0, "query": "...", "mode": "free/paid/any"}
LAST_SWIPE_AT: Dict[int, datetime] = {}  # –∞–Ω—Ç–∏—Å–ø–∞–º –ø–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é

# ========================= –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò API =========================


SCRIPTBLOX_BASE = "https://scriptblox.com"

from datetime import datetime, timedelta


# ----- –ö–≠–® -----
API_CACHE: Dict[str, dict] = {}  # –∫–ª—é—á -> {"data": ..., "expires": datetime}
CACHE_TTL = timedelta(minutes=25)


def make_cache_key(q: str, mode: str, page: int, max_items: int) -> str:
    return f"{q.lower()}|{mode}|{page}|{max_items}"


def get_from_cache(key: str) -> Optional[list]:
    entry = API_CACHE.get(key)
    if not entry:
        return None
    if datetime.now() > entry["expires"]:
        API_CACHE.pop(key, None)  # —É–¥–∞–ª–∏—Ç—å –ø—Ä–æ—Å—Ä–æ—á–µ–Ω–Ω—ã–π
        return None
    return entry["data"]


def save_to_cache(key: str, data: list):
    API_CACHE[key] = {
        "data": data,
        "expires": datetime.now() + CACHE_TTL
    }


# ----- API ScriptBlox -----
async def api_search(q: str, mode: str, page: int = 1, max_items: int = 20) -> List[dict]:
    """
    –ü–æ–∏—Å–∫ —Å–∫—Ä–∏–ø—Ç–æ–≤ —Å –∫—ç—à–µ–º (25 –º–∏–Ω—É—Ç).
    """
    key = make_cache_key(q, mode, page, max_items)
    cached = get_from_cache(key)
    if cached is not None:
        return cached

    params = {
        "q": q,
        "page": page,
        "max": max_items,
        "strict": "true",
        "order": "desc",
    }
    if mode in ("free", "paid"):
        params["mode"] = mode

    url = f"{SCRIPTBLOX_BASE}/api/script/search"
    async with aiohttp.ClientSession() as session:
        async with session.get(url, params=params, timeout=20) as resp:
            if resp.status != 200:
                return []
            data = await resp.json()
            scripts = data.get("result", {}).get("scripts", [])
            save_to_cache(key, scripts)
            return scripts

async def api_trending() -> List[dict]:
    """
    –¢—Ä–µ–Ω–¥—ã ScriptBlox —Å –∫—ç—à–µ–º (25 –º–∏–Ω—É—Ç).
    """
    key = "trending"
    cached = get_from_cache(key)
    if cached is not None:
        return cached

    url = f"{SCRIPTBLOX_BASE}/api/script/trending"
    async with aiohttp.ClientSession() as session:
        async with session.get(url, timeout=20) as resp:
            if resp.status != 200:
                return []
            data = await resp.json()
            res = data.get("result") or data
            if isinstance(res, dict):
                items = res.get("scripts", [])
            else:
                items = res
            items = items[:10]
            save_to_cache(key, items)
            return items





def safe_code(text: str) -> str:
    """–≠–∫—Ä–∞–Ω–∏—Ä—É–µ—Ç –∫–æ–¥ –¥–ª—è HTML <code>...</code>."""
    return html.escape(text or "", quote=False)

def bool_emoji(v: Optional[bool]) -> str:
    return "‚úÖ" if v else "‚ùå"

def format_script_caption(item: dict) -> str:
    # –ò–∑–≤–ª–µ–∫–∞–µ–º –ø–æ–ª—è —Å –∑–∞—â–∏—Ç–æ–π –æ—Ç –æ—Ç—Å—É—Ç—Å—Ç–≤–∏—è
    title = item.get("title") or item.get("name") or "–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è"
    game = item.get("game", {}) or {}
    game_name = game.get("name") or item.get("gameName") or "‚Äî"
    verified = item.get("verified")
    key_required = item.get("key")
    views = item.get("views") or 0
    likes = item.get("likeCount") or item.get("likes") or 0
    created_at = item.get("createdAt") or item.get("created") or ""
    publisher = (item.get("owner") or {}).get("username") if isinstance(item.get("owner"), dict) else (item.get("owner") or "‚Äî")
    script_code = item.get("script") or ""

    caption = (
        f"<b>{html.escape(title)}</b>\n"
        f"üéÆ –ò–≥—Ä–∞: <b>{html.escape(game_name)}</b>\n"
        f"‚òëÔ∏è Verified: {bool_emoji(bool(verified))}\n"
        f"üîë Key System: {bool_emoji(bool(key_required))}\n"
        f"üëÄ –ü—Ä–æ—Å–º–æ—Ç—Ä—ã: <b>{views}</b>\n"
        f"üëç –õ–∞–π–∫–∏: <b>{likes}</b>\n"
        f"üìÖ –î–∞—Ç–∞: {html.escape(str(created_at))}\n"
        f"üë§ –ê–≤—Ç–æ—Ä: {html.escape(str(publisher))}\n\n"
    )
    if script_code:
        caption += f"<b>–°–∫—Ä–∏–ø—Ç:</b>\n<code>{safe_code(script_code)}</code>"
    else:
        caption += "<i>–ö–æ–¥ —Å–∫—Ä–∏–ø—Ç–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç.</i>"
    return caption

def extract_image_url(item: dict) -> Optional[str]:
    # –ü—Ä–æ–±—É–µ–º –≤–∑—è—Ç—å –∫–∞—Ä—Ç–∏–Ω–∫—É —Å–∫—Ä–∏–ø—Ç–∞, –∑–∞—Ç–µ–º –∏–≥—Ä—ã
    img = item.get("image") or item.get("thumbnail") or None
    if not img:
        game = item.get("game", {}) or {}
        img = game.get("imageUrl") or game.get("thumbnail")
    return img

def search_menu_kb(user_id: int) -> InlineKeyboardMarkup:
    kb = InlineKeyboardBuilder()
    kb.button(text=RU["search_btn_new"], callback_data="search:new")
    kb.button(text=RU["search_btn_trends"], callback_data="search:trends")
    kb.button(text=RU["search_back"], callback_data="menu:root")
    kb.adjust(1)
    return kb.as_markup()

def search_mode_kb() -> InlineKeyboardMarkup:
    kb = InlineKeyboardBuilder()
    kb.button(text=RU["search_mode_any"], callback_data="search:mode:any")
    kb.button(text=RU["search_mode_free"], callback_data="search:mode:free")
    kb.button(text=RU["search_mode_paid"], callback_data="search:mode:paid")
    kb.button(text=RU["search_back"], callback_data="search:menu")
    kb.adjust(2, 1)
    return kb.as_markup()

def search_nav_kb(index: int, total: int) -> InlineKeyboardMarkup:
    kb = InlineKeyboardBuilder()
    # –ö–Ω–æ–ø–∫–∏ –Ω–∞–≤–∏–≥–∞—Ü–∏–∏ –∫–∞—Ä—Ç–æ—á–µ–∫
    kb.button(text="‚èÆ", callback_data="search:first")
    kb.button(text="‚¨ÖÔ∏è", callback_data="search:prev")
    kb.button(text=f"{index+1}/{total}", callback_data="noop")
    kb.button(text="‚û°Ô∏è", callback_data="search:next")
    kb.button(text="‚è≠", callback_data="search:last")
    kb.button(text=RU["search_back"], callback_data="search:menu")
    kb.adjust(5, 1)
    return kb.as_markup()

def trends_page_kb(items: List[dict], page: int, per_page: int = 5) -> InlineKeyboardMarkup:
    kb = InlineKeyboardBuilder()
    start = page * per_page
    end = min(start + per_page, len(items))
    for i in range(start, end):
        it = items[i]
        title = it.get("title") or it.get("name") or f"Script {i+1}"
        kb.button(text=f"{title}", callback_data=f"trend:open:{i}")
    # –ø–∞–≥–∏–Ω–∞—Ü–∏—è
    pages = (len(items) + per_page - 1) // per_page
    # —Å—Ç—Ä–µ–ª–∫–∏
    if pages > 1:
        nav_row = []
        if page > 0:
            kb.button(text="‚¨ÖÔ∏è –ü—Ä–µ–¥.", callback_data=f"trend:page:{page-1}")
        if page < pages - 1:
            kb.button(text="–°–ª–µ–¥. ‚û°Ô∏è", callback_data=f"trend:page:{page+1}")
    kb.button(text=RU["trends_back"], callback_data="search:menu")
    kb.adjust(1)
    return kb.as_markup()

# ========================= –ë–û–¢ =========================
bot = Bot(
    token=TOKEN,
    default=DefaultBotProperties(parse_mode=ParseMode.HTML)
)
dp = Dispatcher()

# ========================= Chache =========================

@dp.message(Command("cacheinfo"))
async def cmd_cache_info(m: Message):

    if m.from_user.id not in ADMIN_IDS:
        await m.answer("‚õî –£ —Ç–µ–±—è –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–π –∫–æ–º–∞–Ω–¥–µ.")
        return

    now = datetime.now()
    total = len(API_CACHE)
    expired = sum(1 for v in API_CACHE.values() if now > v["expires"])
    active = total - expired

    text = (
        "<b>üì¶ –ö—ç—à ScriptBlox</b>\n"
        f"–í—Å–µ–≥–æ –∑–∞–ø–∏—Å–µ–π: <b>{total}</b>\n"
        f"–ê–∫—Ç–∏–≤–Ω—ã–µ: <b>{active}</b>\n"
        f"–ü—Ä–æ—Å—Ä–æ—á–µ–Ω–Ω—ã–µ: <b>{expired}</b>"
    )
    await m.answer(text, parse_mode=ParseMode.HTML)


# --------------- —Å—Ç–∞—Ä—Ç / start —Å deep-link -----------------
@dp.message(CommandStart())
async def cmd_start(m: Message, state: FSMContext):
    # –∞–≤—Ç–æ-—Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    if not get_user(m.from_user.id):
        add_user(m.from_user.id, DEFAULT_LANG)

    target: Optional[Tuple[int, int]] = None
    if m.text and len(m.text.split()) > 1:
        arg = m.text.split(maxsplit=1)[1]
        if arg.startswith("idc") and "ids" in arg:
            try:
                a = arg.replace("idc", "").split("ids")
                target = (int(a[0]), int(a[1]))
            except Exception:
                target = None

    if not await ensure_subscribed(m, state, target):
        return

    if target:
        await open_script_card(m.from_user.id, m, target[0], target[1])
    else:
        await show_main_menu(m.from_user.id, m)

# --------------- Menu Start -----------------
async def show_main_menu(user_id: int, where: Message | CallbackQuery):
    user = get_user(user_id)
    lang = user["lang"] if user else DEFAULT_LANG
    L = LOCALES.get(lang, RU)

    text = f"<b>{L['welcome_title']}</b>\n\n" + RU["subscription_required"]

    if isinstance(where, Message):
        await where.answer_photo(
            photo=IMAGES["menu"],
            caption=text,
            reply_markup=menu_keyboard(user_id),
            parse_mode=ParseMode.HTML
        )
    else:
        try:
            await where.message.edit_media(
                media=InputMediaPhoto(
                    media=IMAGES["menu"],
                    caption=text,
                    parse_mode=ParseMode.HTML
                ),
                reply_markup=menu_keyboard(user_id)
            )
        except Exception:
            await where.message.delete()
            await where.message.answer_photo(
                photo=IMAGES["menu"],
                caption=text,
                reply_markup=menu_keyboard(user_id),
                parse_mode=ParseMode.HTML
            )
# --------------- –ö–Ω–æ–ø–∫–∏ –ø–æ–¥–ø–∏—Å–∫–∏ -----------------
@dp.callback_query(F.data == "subs:check")
async def cb_subs_check(c: CallbackQuery, state: FSMContext):
    if not await ensure_subscribed(c, state):
        await c.answer("–ï—â—ë –Ω–µ –ø–æ–¥–ø–∏—Å–∞–Ω—ã.", show_alert=False)
        return
    await c.answer(t(c.from_user.id, "sub_ok"), show_alert=False)
    data = await state.get_data()
    pending = data.get("pending_target")
    if pending:
        await open_script_card(c.from_user.id, c, pending["cat"], pending["script"])  # type: ignore
        await state.update_data(pending_target=None)
    else:
        await show_main_menu(c.from_user.id, c)

@dp.callback_query(F.data == "subs:skip")
async def cb_subs_skip(c: CallbackQuery, state: FSMContext):
    if not DEBUG_SKIP_SUBS:
        await c.answer("Debug off")
        return
    data = await state.get_data()
    pending = data.get("pending_target")
    if pending:
        await open_script_card(c.from_user.id, c, pending["cat"], pending["script"])  # type: ignore
        await state.update_data(pending_target=None)
    else:
        await show_main_menu(c.from_user.id, c)

# --------------- –ú–µ–Ω—é -----------------
@dp.message(Command("menu"))
async def cmd_menu(m: Message, state: FSMContext):
    if not await ensure_subscribed(m, state):
        return
    await show_main_menu(m.from_user.id, m)

@dp.callback_query(F.data == "menu:root")
async def cb_menu_root(c: CallbackQuery, state: FSMContext):
    if not await ensure_subscribed(c, state):
        return
    await show_main_menu(c.from_user.id, c)

@dp.callback_query(F.data == "menu:settings")
async def cb_settings(c: CallbackQuery, state: FSMContext):
    if not await ensure_subscribed(c, state):
        return

    kb = InlineKeyboardBuilder()
    kb.button(text=RU["lang_ru"], callback_data="lang:ru")
    kb.button(text=RU["lang_en"], callback_data="lang:en")
    kb.button(text=t(c.from_user.id, "back"), callback_data="menu:root")
    kb.adjust(1)

    caption = t(c.from_user.id, "change_lang")

    try:
        # –µ—Å–ª–∏ —Å–æ–æ–±—â–µ–Ω–∏–µ –±—ã–ª–æ —Ñ–æ—Ç–æ ‚Üí –∑–∞–º–µ–Ω—è–µ–º —Ñ–æ—Ç–æ –∏ –ø–æ–¥–ø–∏—Å—å
        await c.message.edit_media(
            InputMediaPhoto(
                media=IMAGES["settings"],  # –∫–∞—Ä—Ç–∏–Ω–∫–∞ –¥–ª—è –º–µ–Ω—é –Ω–∞—Å—Ç—Ä–æ–µ–∫
                caption=caption,
                parse_mode="HTML"
            ),
            reply_markup=kb.as_markup()
        )
    except Exception:
        # –µ—Å–ª–∏ —Å–æ–æ–±—â–µ–Ω–∏–µ –±—ã–ª–æ —Ç–µ–∫—Å—Ç–æ–º ‚Üí —É–¥–∞–ª—è–µ–º –∏ —à–ª—ë–º –Ω–æ–≤–æ–µ —Ñ–æ—Ç–æ
        await c.message.delete()
        await c.message.answer_photo(
            photo=IMAGES["settings"],
            caption=caption,
            reply_markup=kb.as_markup(),
            parse_mode="HTML"
        )

@dp.callback_query(F.data.startswith("lang:"))
async def cb_set_lang(c: CallbackQuery):
    lang = c.data.split(":", 1)[1]
    if lang in LOCALES:
        update_user_lang(c.from_user.id, lang)
    await show_main_menu(c.from_user.id, c)

# --------------- –ö–∞—Ç–∞–ª–æ–≥ -----------------
# === –ö–∞—Ç–∞–ª–æ–≥ ===
@dp.message(Command("catalog"))
async def cmd_catalog(m: Message, state: FSMContext):
    if not await ensure_subscribed(m, state):
        return
    cats = get_categories()   # –∏–∑ db.py
    await m.answer(
        t(m.from_user.id, "choose_category"),
        reply_markup=categories_keyboard(m.from_user.id, cats)
    )


@dp.callback_query(F.data == "menu:catalog")
async def cb_catalog(c: CallbackQuery, state: FSMContext):
    if not await ensure_subscribed(c, state):
        return
    cats = get_categories()

    try:
        await c.message.edit_media(
            InputMediaPhoto(
                media=IMAGES["catalog"],
                caption=t(c.from_user.id, "choose_category")
            ),
            reply_markup=categories_keyboard(c.from_user.id, cats)
        )
    except Exception:
        await c.message.delete()
        await c.message.answer_photo(
            photo=IMAGES["catalog"],
            caption=t(c.from_user.id, "choose_category"),
            reply_markup=categories_keyboard(c.from_user.id, cats)
        )


@dp.callback_query(F.data == "catalog:root")
async def cb_catalog_root(c: CallbackQuery, state: FSMContext):
    return await cb_catalog(c, state)


@dp.callback_query(F.data.startswith("cat:"))
async def cb_open_cat(c: CallbackQuery, state: FSMContext):
    if not await ensure_subscribed(c, state):
        return
    cat_id = int(c.data.split(":")[1])
    cat = find_category(cat_id)   # —Ç–µ–ø–µ—Ä—å –±–µ—Ä—ë–º –∫–∞—Ç–µ–≥–æ—Ä–∏—é –∏–∑ –±–∞–∑—ã
    if not cat:
        await c.answer("–ö–∞—Ç–µ–≥–æ—Ä–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞", show_alert=True)
        return

    scripts = get_scripts(cat_id)  # —Å–∫—Ä–∏–ø—Ç—ã –∏–∑ –±–∞–∑—ã
    caption = t(c.from_user.id, "scripts_in_cat", name=cat["name"])

    try:
        await c.message.edit_media(
            InputMediaPhoto(
                media=IMAGES["scripts"],
                caption=caption,
                parse_mode="HTML"
            ),
            reply_markup=scripts_keyboard(c.from_user.id, cat, scripts)
        )
    except Exception:
        await c.message.delete()
        await c.message.answer_photo(
            photo=IMAGES["scripts"],
            caption=caption,
            reply_markup=scripts_keyboard(c.from_user.id, cat, scripts),
            parse_mode="HTML"
        )


# ==== min


# === –û—Ç–∫—Ä—ã—Ç—å –∫–∞—Ä—Ç–æ—á–∫—É —Å–∫—Ä–∏–ø—Ç–∞ ===
async def open_script_card(user_id: int, where: Message | CallbackQuery, cat_id: int, script_id: int):
    cat = find_category(cat_id)   # –∫–∞—Ç–µ–≥–æ—Ä–∏—è –∏–∑ –±–∞–∑—ã
    if not cat:
        if isinstance(where, Message):
            await where.answer("–ö–∞—Ç–µ–≥–æ—Ä–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")
        else:
            await where.message.answer("–ö–∞—Ç–µ–≥–æ—Ä–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")
        return

    s = find_script(cat_id, script_id)   # —Å–∫—Ä–∏–ø—Ç –∏–∑ –±–∞–∑—ã
    if not s:
        if isinstance(where, Message):
            await where.answer("–°–∫—Ä–∏–ø—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω")
        else:
            await where.message.answer("–°–∫—Ä–∏–ø—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω")
        return

    text = f"<b>{s['name']}</b>\n\n{s['description']}"

    try:
        # –µ—Å–ª–∏ —Å–æ–æ–±—â–µ–Ω–∏–µ –±—ã–ª–æ —Ñ–æ—Ç–æ ‚Üí –æ–±–Ω–æ–≤–ª—è–µ–º —á–µ—Ä–µ–∑ edit_media
        await where.message.edit_media(
            InputMediaPhoto(
                media=IMAGES["scripts"],
                caption=text,
                parse_mode="HTML"
            ),
            reply_markup=script_card_kb(user_id, cat_id, script_id)
        )
    except Exception:
        # –µ—Å–ª–∏ —Å—Ç–∞—Ä–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –±—ã–ª–æ —Ç–µ–∫—Å—Ç–æ–º ‚Üí —É–¥–∞–ª—è–µ–º –∏ —à–ª—ë–º –Ω–æ–≤–æ–µ —Å —Ñ–æ—Ç–æ
        if isinstance(where, Message):
            await where.answer_photo(
                photo=IMAGES["scripts"],
                caption=text,
                reply_markup=script_card_kb(user_id, cat_id, script_id),
                parse_mode="HTML"
            )
        else:
            await where.message.delete()
            await where.message.answer_photo(
                photo=IMAGES["scripts"],
                caption=text,
                reply_markup=script_card_kb(user_id, cat_id, script_id),
                parse_mode="HTML"
            )


# === –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–æ–∫ "script:cat_id:script_id" ===
@dp.callback_query(F.data.startswith("script:"))
async def cb_open_script(c: CallbackQuery, state: FSMContext):
    if not await ensure_subscribed(c, state):
        return
    _, cat_id, script_id = c.data.split(":")
    await open_script_card(c.from_user.id, c, int(cat_id), int(script_id))

# --------------- –ê–î–ú–ò–ù: —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ -----------------
@dp.message(Command("statsu"))
async def cmd_stats(m: Message):
    if m.from_user.id not in ADMIN_IDS:
        return

    users = get_all_users()  # <-- —Ç–µ–ø–µ—Ä—å –∏–∑ –±–∞–∑—ã
    total = len(users)
    now = datetime.now(timezone.utc)
    today = 0
    week = 0

    for u in users:
        joined = datetime.fromisoformat(u["joined"])
        if joined.date() == now.date():
            today += 1
        if joined >= now - timedelta(days=7):
            week += 1

    text = (
        f"<b>{RU['stats_title']}</b>\n"
        f"{RU['stats_total'].format(n=total)}\n"
        f"{RU['stats_today'].format(n=today)}\n"
        f"{RU['stats_week'].format(n=week)}"
    )
    await m.answer(text)

# --------------- –ê–î–ú–ò–ù: —Ä–∞—Å—Å—ã–ª–∫–∞ -----------------
@dp.message(Command("send"))
async def cmd_send(m: Message, state: FSMContext):
    if m.from_user.id not in ADMIN_IDS:
        return
    await state.set_state(SendStates.waiting_message)
    await m.answer("–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ç–µ–∫—Å—Ç/—Ñ–æ—Ç–æ/–≤–∏–¥–µ–æ/—Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è —Ä–∞—Å—Å—ã–ª–∫–∏. /cancel ‚Äî –æ—Ç–º–µ–Ω–∞")

@dp.message(SendStates.waiting_message)
async def do_broadcast(m: Message, state: FSMContext):
    if m.from_user.id not in ADMIN_IDS:
        return
    user_ids = get_all_user_ids()
    sent = 0
    for uid in user_ids:
        try:
            await m.copy_to(chat_id=uid)
            sent += 1
            await asyncio.sleep(0.05)  # –∑–∞–¥–µ—Ä–∂–∫–∞ —á—Ç–æ–±—ã –Ω–µ —Å–ª–æ–≤–∏—Ç—å flood
        except Exception:
            pass
    await state.clear()
    await m.answer(f"–†–∞—Å—Å—ã–ª–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞. –î–æ—Å—Ç–∞–≤–ª–µ–Ω–æ: {sent}")

# --------------- –ê–î–ú–ò–ù: /editcatalog -----------------
@dp.message(Command("editcatalog"))
async def cmd_edit(m: Message, state: FSMContext):
    if m.from_user.id not in ADMIN_IDS:
        return
    kb = InlineKeyboardBuilder()
    kb.button(text="üóÇ –ö–∞—Ç–µ–≥–æ—Ä–∏–∏", callback_data="ed:categories")
    kb.button(text="üìÉ –°–∫—Ä–∏–ø—Ç—ã", callback_data="ed:scripts")
    kb.button(text="‚ùå –û—Ç–º–µ–Ω–∞", callback_data="ed:cancel")
    kb.adjust(1)
    await m.answer("–ß—Ç–æ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å?", reply_markup=kb.as_markup())


@dp.callback_query(F.data == "ed:cancel")
async def ed_cancel(c: CallbackQuery, state: FSMContext):
    await state.clear()
    await show_main_menu(c.from_user.id, c)


# --- –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
@dp.callback_query(F.data == "ed:categories")
async def ed_categories(c: CallbackQuery, state: FSMContext):
    if c.from_user.id not in ADMIN_IDS:
        return
    await state.set_state(EditCategories.choose_action)
    kb = InlineKeyboardBuilder()
    kb.button(text="üóÇ –î–æ–±–∞–≤–∏—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é", callback_data="edc:add")
    kb.button(text="‚úÇÔ∏è –£–¥–∞–ª–∏—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é", callback_data="edc:del")
    kb.button(text="‚ùå –û—Ç–º–µ–Ω–∞", callback_data="ed:cancel")
    kb.adjust(1)
    await c.message.edit_text("–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:", reply_markup=kb.as_markup())


@dp.callback_query(EditCategories.choose_action, F.data == "edc:add")
async def edc_add(c: CallbackQuery, state: FSMContext):
    await state.set_state(EditCategories.waiting_new_name)
    await c.message.edit_text("üñã –ù–∞–ø–∏—à–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –Ω–æ–≤–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ (–¥–æ 20 —Å–∏–º–≤–æ–ª–æ–≤):")


@dp.message(EditCategories.waiting_new_name)
async def edc_add_name(m: Message, state: FSMContext):
    name = (m.text or "").strip()[:30]
    add_category(name)
    await state.clear()
    await m.answer(RU["category_added"])


@dp.callback_query(EditCategories.choose_action, F.data == "edc:del")
async def edc_del(c: CallbackQuery, state: FSMContext):
    cats = get_categories()
    kb = InlineKeyboardBuilder()
    for cat in cats:
        kb.button(text=f"{cat['name']} (id {cat['id']})", callback_data=f"edc:choose:{cat['id']}")
    kb.button(text="–û—Ç–º–µ–Ω–∞", callback_data="ed:cancel")
    kb.adjust(1)
    await c.message.edit_text("–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—é –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è:", reply_markup=kb.as_markup())


@dp.callback_query(F.data.startswith("edc:choose:"))
async def edc_del_confirm(c: CallbackQuery, state: FSMContext):
    cat_id = int(c.data.split(":")[-1])
    cats = get_categories()
    cat = next((x for x in cats if x["id"] == cat_id), None)
    if not cat:
        await c.answer("–ù–µ –Ω–∞–π–¥–µ–Ω–æ", show_alert=True)
        return
    await state.set_state(EditCategories.confirm_delete)
    await state.update_data(del_cat=cat_id)
    kb = InlineKeyboardBuilder()
    kb.button(text="‚úÖ –î–∞", callback_data="edc:yes")
    kb.button(text="‚ùå –ù–µ—Ç", callback_data="ed:categories")
    kb.adjust(2)
    await c.message.edit_text(RU["are_you_sure_delete_cat"].format(name=cat["name"]), reply_markup=kb.as_markup())


@dp.callback_query(EditCategories.confirm_delete, F.data == "edc:yes")
async def edc_del_yes(c: CallbackQuery, state: FSMContext):
    data = await state.get_data()
    cat_id = int(data.get("del_cat"))
    delete_category(cat_id)
    await state.clear()
    await c.message.edit_text(RU["deleted"])


# --- —Å–∫—Ä–∏–ø—Ç—ã
@dp.callback_query(F.data == "ed:scripts")
async def ed_scripts(c: CallbackQuery, state: FSMContext):
    if c.from_user.id not in ADMIN_IDS:
        return
    await state.set_state(EditScripts.choose_action)
    kb = InlineKeyboardBuilder()
    kb.button(text="üìÉ –î–æ–±–∞–≤–∏—Ç—å –°–∫—Ä–∏–ø—Ç", callback_data="eds:add")
    kb.button(text="üóë –£–¥–∞–ª–∏—Ç—å –°–∫—Ä–∏–ø—Ç", callback_data="eds:del")
    kb.button(text="‚ùå –û—Ç–º–µ–Ω–∞", callback_data="ed:cancel")
    kb.adjust(1)
    await c.message.edit_text("–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:", reply_markup=kb.as_markup())


@dp.callback_query(EditScripts.choose_action, F.data == "eds:add")
async def eds_add_choose_cat(c: CallbackQuery, state: FSMContext):
    await state.set_state(EditScripts.choose_cat)
    cats = get_categories()
    kb = InlineKeyboardBuilder()
    for cat in cats:
        kb.button(text=f"{cat['name']} (id {cat['id']})", callback_data=f"eds:add:cat:{cat['id']}")
    kb.button(text="–û—Ç–º–µ–Ω–∞", callback_data="ed:cancel")
    kb.adjust(1)
    await c.message.edit_text("–í –∫–∞–∫—É—é –∫–∞—Ç–µ–≥–æ—Ä–∏—é –¥–æ–±–∞–≤–∏—Ç—å —Å–∫—Ä–∏–ø—Ç?", reply_markup=kb.as_markup())


@dp.callback_query(EditScripts.choose_cat, F.data.startswith("eds:add:cat:"))
async def eds_add_got_cat(c: CallbackQuery, state: FSMContext):
    cat_id = int(c.data.split(":")[-1])
    await state.update_data(cat_id=cat_id)
    await state.set_state(EditScripts.waiting_script_name)
    await c.message.edit_text("üñã –í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ —Å–∫—Ä–∏–ø—Ç–∞:")


@dp.message(EditScripts.waiting_script_name)
async def eds_add_name(m: Message, state: FSMContext):
    await state.update_data(script_name=(m.text or "").strip()[:50])
    await state.set_state(EditScripts.waiting_script_desc)
    await m.answer("üñã –í–≤–µ–¥–∏—Ç–µ –æ–ø–∏—Å–∞–Ω–∏–µ —Å–∫—Ä–∏–ø—Ç–∞ (HTML —Ñ–æ—Ä–º–∞—Ç —Ä–∞–∑—Ä–µ—à—ë–Ω):")


@dp.message(EditScripts.waiting_script_desc)
async def eds_add_desc(m: Message, state: FSMContext):
    data = await state.get_data()
    add_script(
        cat_id=int(data["cat_id"]),
        name=data["script_name"],
        description=m.html_text or m.text or ""
    )
    await state.clear()
    await m.answer(RU["script_added"])




@dp.callback_query(EditScripts.choose_action, F.data == "eds:del")
async def eds_del_choose_cat(c: CallbackQuery, state: FSMContext):
    await state.set_state(EditScripts.choose_cat_delete)
    cats = get_categories()
    kb = InlineKeyboardBuilder()
    for cat in cats:
        kb.button(text=f"{cat['name']} (id {cat['id']})", callback_data=f"eds:del:cat:{cat['id']}")
    kb.button(text="–û—Ç–º–µ–Ω–∞", callback_data="ed:cancel")
    kb.adjust(1)
    await c.message.edit_text("–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—é —Å–∫—Ä–∏–ø—Ç–∞ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è:", reply_markup=kb.as_markup())


@dp.callback_query(EditScripts.choose_cat_delete, F.data.startswith("eds:del:cat:"))
async def eds_del_choose_script(c: CallbackQuery, state: FSMContext):
    cat_id = int(c.data.split(":")[-1])
    await state.update_data(cat_id=cat_id)
    scripts = get_scripts(cat_id)
    if not scripts:
        await c.answer("–í —ç—Ç–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –Ω–µ—Ç —Å–∫—Ä–∏–ø—Ç–æ–≤", show_alert=True)
        return
    kb = InlineKeyboardBuilder()
    for s in scripts:
        kb.button(text=f"{s['name']} (id {s['id']})", callback_data=f"eds:del:scr:{s['id']}")
    kb.button(text="–û—Ç–º–µ–Ω–∞", callback_data="ed:cancel")
    kb.adjust(1)
    await c.message.edit_text("–í—ã–±–µ—Ä–∏—Ç–µ —Å–∫—Ä–∏–ø—Ç –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è:", reply_markup=kb.as_markup())


@dp.callback_query(EditScripts.choose_cat_delete, F.data.startswith("eds:del:scr:"))
async def eds_del_confirm(c: CallbackQuery, state: FSMContext):
    script_id = int(c.data.split(":")[-1])
    await state.set_state(EditScripts.confirm_delete)
    await state.update_data(del_script=script_id)
    kb = InlineKeyboardBuilder()
    kb.button(text="‚úÖ –î–∞", callback_data="eds:yes")
    kb.button(text="‚ùå –ù–µ—Ç", callback_data="ed:scripts")
    kb.adjust(2)
    await c.message.edit_text("–£–¥–∞–ª–∏—Ç—å —ç—Ç–æ—Ç —Å–∫—Ä–∏–ø—Ç?", reply_markup=kb.as_markup())


@dp.callback_query(EditScripts.confirm_delete, F.data == "eds:yes")
async def eds_del_yes(c: CallbackQuery, state: FSMContext):
    data = await state.get_data()
    script_id = int(data["del_script"])
    delete_script(script_id)
    await state.clear()
    await c.message.edit_text(RU["deleted"])

# --------------- –ü–£–ù–ö–¢–´ –ú–ï–ù–Æ, –ù–ï –†–ï–ê–õ–ò–ó–û–í–ê–ù–ù–´–ï -------------


@dp.callback_query(F.data == "menu:services")
async def not_implemented3(c: CallbackQuery, state: FSMContext):
    if not await ensure_subscribed(c, state):
        return
    await c.answer("–î–∞–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –≤ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ.")



@dp.callback_query(F.data == "menu:profile")
async def not_implemented4(c: CallbackQuery, state: FSMContext):
    if not await ensure_subscribed(c, state):
        return

    u = get_user(c.from_user.id)
    text = (
        f"<b>–ü—Ä–æ—Ñ–∏–ª—å</b>\n\n"
        f"ID: <code>{c.from_user.id}</code>\n"
        f"–Ø–∑—ã–∫: {u.get('lang', 'ru')}"
    )
    markup = back_kb(c.from_user.id, "menu:root")
    photo_url = "https://i.postimg.cc/4Nq07Nxh/profile.png"

    try:
        if c.message.photo:  # –µ—Å–ª–∏ —É–∂–µ –±—ã–ª–æ —Ñ–æ—Ç–æ ‚Üí —Ä–µ–¥–∞–∫—Ç–∏—Ä—É–µ–º
            await c.message.edit_media(
                media=InputMediaPhoto(media=photo_url, caption=text, parse_mode="HTML"),
                reply_markup=markup
            )
        else:  # –µ—Å–ª–∏ —Ä–∞–Ω—å—à–µ –±—ã–ª —Ç–µ–∫—Å—Ç ‚Üí –∑–∞–º–µ–Ω—è–µ–º –Ω–∞ —Ñ–æ—Ç–æ
            await c.message.edit_media(
                media=InputMediaPhoto(media=photo_url, caption=text, parse_mode="HTML"),
                reply_markup=markup
            )
    except Exception:
        # –µ—Å–ª–∏ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å –Ω–µ–ª—å–∑—è (–Ω–∞–ø—Ä–∏–º–µ—Ä, –±—ã–ª–æ —á–∏—Å—Ç–æ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –±–µ–∑ —Ñ–æ—Ç–æ)
        await c.message.answer_photo(photo=photo_url, caption=text, reply_markup=markup)


# ============================ BYPASS + –í–°–ï –ß–¢–û –° –ù–ò–ú –°–í–Ø–ó–ê–ù–û ============================ 


RATE_LIMIT = Semaphore(23)
RESET_TIME = 10
last_reset = time.time()

@dp.callback_query(F.data == "menu:bypass")
async def cb_bypass_start(c: CallbackQuery, state: FSMContext):
    if not await ensure_subscribed(c, state):
        return
    await state.set_state(BypassFSM.waiting_url)

    caption = "üîó –í—Å—Ç–∞–≤—å—Ç–µ —Å—Å—ã–ª–∫—É –¥–ª—è –±–∞–π–ø–∞—Å–∞:"
    try:
        await c.message.edit_media(
            InputMediaPhoto(
                media=IMAGES["bypass"],
                caption=caption,
                parse_mode="HTML"
            ),
            reply_markup=bypass_back_kb(c.from_user.id)
        )
    except Exception:
        await c.message.answer_photo(
            photo=IMAGES["bypass"],
            caption=caption,
            parse_mode="HTML",
            reply_markup=bypass_back_kb(c.from_user.id)
        )


def detect_provider(url: str) -> str:
    """–û–ø—Ä–µ–¥–µ–ª—è–µ–º –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞ –ø–æ –¥–æ–º–µ–Ω—É"""
    domain = urlparse(url).netloc.lower()
    domain = domain.replace("www.", "")
    return re.sub(r"\.(com|ru|org|net|io|xyz|info|co)$", "", domain) or "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –ø—Ä–æ–≤–∞–π–¥–µ—Ä"


def bypass_result_kb(user_id: int, result: str):
    kb = InlineKeyboardBuilder()
    kb.button(text="üìã –°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å", switch_inline_query=result)
    for b in bypass_back_kb(user_id).inline_keyboard:
        kb.row(*b)
    return kb.as_markup()


@dp.message(BypassFSM.waiting_url)
async def cb_bypass_url(m: Message, state: FSMContext):
    url = (m.text or "").strip()
    if not url.startswith("http"):
        await m.answer("‚ùå –≠—Ç–æ –Ω–µ –ø–æ—Ö–æ–∂–µ –Ω–∞ —Å—Å—ã–ª–∫—É. –ü–æ–ø—Ä–æ–±—É–π —Å–Ω–æ–≤–∞.", reply_markup=bypass_back_kb(m.from_user.id))
        return

    provider = detect_provider(url)

    msg = await m.answer_photo(
        photo=IMAGES["loading"],
        caption="‚è≥ –ë–∞–π–ø–∞—Å—Å –≤ –ø—Ä–æ—Ü–µ—Å—Å–µ...",
        reply_markup=bypass_back_kb(m.from_user.id)
    )

    api_url = f"https://api.bypass.vip/premium/bypass?url={url}"
    headers = {"x-api-key": "71824f05-c5f0-4141-a610-1469e634cc71"}
    start_time = time.perf_counter()
    result_text = "‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –±–∞–π–ø–∞—Å–µ."

    global last_reset
    now = time.time()
    if now - last_reset > RESET_TIME:
        while RATE_LIMIT._value < 23:
            RATE_LIMIT.release()
        last_reset = now

    try:
        async with RATE_LIMIT:
            async with aiohttp.ClientSession() as session:
                async with session.get(api_url, headers=headers, timeout=20) as resp:
                    text = await resp.text()
                    # üì° –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ —É–±—Ä–∞–Ω–æ

                    if 200 <= resp.status < 300:  # –ª—é–±—ã–µ 2xx —Å—á–∏—Ç–∞–µ–º —É—Å–ø–µ—à–Ω—ã–º–∏
                        try:
                            data = await resp.json()
                            result_text = (
                                data.get("destination")
                                or data.get("result")
                                or data.get("url")
                                or f"‚ö†Ô∏è –ù–µ–æ–∂–∏–¥–∞–Ω–Ω—ã–π –æ—Ç–≤–µ—Ç API:\n\n{data}"
                            )
                        except Exception:
                            # –ï—Å–ª–∏ JSON –Ω–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–∞—Ä—Å–∏—Ç—å, –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —á–∏—Å—Ç—ã–π —Ç–µ–∫—Å—Ç
                            result_text = text.strip() or "‚ö†Ô∏è –ü—É—Å—Ç–æ–π –æ—Ç–≤–µ—Ç API."
                    else:
                        result_text = f"‚ùå API –≤–µ—Ä–Ω—É–ª —Å—Ç–∞—Ç—É—Å {resp.status}:\n\n{text}"

    except Exception as e:
        result_text = f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—Ä–æ—Å–µ: {e}"

    elapsed = round(time.perf_counter() - start_time - 0.3, 2)
    if elapsed < 0:
        elapsed = 0

    try:
        await msg.delete()
    except Exception:
        pass

    caption = (
        f"<b>[‚ö° –í–ê–®–ê –°–°–´–õ–ö–ê –ó–ê–ë–ê–ô–ü–ê–°–ï–ù–ê ‚ö°]</b>\n"
        f"üåê –ü—Ä–æ–≤–∞–π–¥–µ—Ä: <b>{provider}</b>\n"
        f"‚è± –í—Ä–µ–º—è –±–∞–π–ø–∞—Å–∞: {elapsed} —Å–µ–∫.\n\n"
        "‚úÖ <b>–†–µ–∑—É–ª—å—Ç–∞—Ç:</b>\n\n"
        f"<code>{result_text}</code>"
    )

    await m.answer_photo(
        photo=IMAGES["bypassed"],
        caption=caption,
        parse_mode="HTML",
        reply_markup=bypass_result_kb(m.from_user.id, result_text)
    )

    await state.clear()


# ========================= –ü–û–ò–°–ö –°–ö–†–ò–ü–¢–û–í (ScriptBlox) =========================

@dp.callback_query(F.data == "menu:search")
async def cb_search_menu(c: CallbackQuery, state: FSMContext):
    if not await ensure_subscribed(c, state):
        return
    await state.clear()

    caption = RU["search_menu_title"]

    try:
        # –µ—Å–ª–∏ –ø—Ä–µ–¥—ã–¥—É—â–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –±—ã–ª–æ —Ñ–æ—Ç–æ
        await c.message.edit_media(
            InputMediaPhoto(
                media=IMAGES["search"],                                             
                caption=caption,
                parse_mode="HTML"
            ),
            reply_markup=search_menu_kb(c.from_user.id)
        )
    except Exception:
        # –µ—Å–ª–∏ –ø—Ä–µ–¥—ã–¥—É—â–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –±—ã–ª–æ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ
        await c.message.delete()
        await c.message.answer_photo(
            photo=IMAGES["search"],
            caption=caption,
            reply_markup=search_menu_kb(c.from_user.id),
            parse_mode="HTML"
        )



@dp.callback_query(F.data == "search:menu")
async def cb_search_menu_back(c: CallbackQuery, state: FSMContext):
    await cb_search_menu(c, state)

# ---- –¢—Ä–µ–Ω–¥—ã ----
@dp.callback_query(F.data == "search:trends")
async def cb_trends(c: CallbackQuery, state: FSMContext):
    if not await ensure_subscribed(c, state):
        return

    caption_loading = RU["trends_title"] + "\n\n–ó–∞–≥—Ä—É–∂–∞—é..."
    try:
        # –°–æ–æ–±—â–µ–Ω–∏–µ "–ó–∞–≥—Ä—É–∂–∞—é..." —Å –∫–∞—Ä—Ç–∏–Ω–∫–æ–π loading
        await c.message.edit_media(
            InputMediaPhoto(
                media=IMAGES["loading"],
                caption=caption_loading,
                parse_mode="HTML"
            )
        )
    except Exception:
        await c.message.delete()
        await c.message.answer_photo(
            photo=IMAGES["loading"],
            caption=caption_loading,
            parse_mode="HTML"
        )

    items = await get_trends_cached()
    if not items:
        caption_fail = "–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Ç—Ä–µ–Ω–¥—ã."
        try:
            await c.message.edit_media(
                InputMediaPhoto(
                    media=IMAGES["trends"],
                    caption=caption_fail,
                    parse_mode="HTML"
                ),
                reply_markup=search_menu_kb(c.from_user.id)
            )
        except Exception:
            await c.message.delete()
            await c.message.answer_photo(
                photo=IMAGES["trends"],
                caption=caption_fail,
                parse_mode="HTML",
                reply_markup=search_menu_kb(c.from_user.id)
            )
        return

    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –∫–µ—à —Ç—Ä–µ–Ω–¥—ã –¥–ª—è –æ—Ç–∫—Ä—ã—Ç–∏—è –∫–∞—Ä—Ç–æ—á–µ–∫ –ø–æ –∏–Ω–¥–µ–∫—Å—É
    SEARCH_CACHE[c.from_user.id] = {"trends": items}

    caption_ready = RU["trends_title"]
    try:
        await c.message.edit_media(
            InputMediaPhoto(
                media=IMAGES["trends"],
                caption=caption_ready,
                parse_mode="HTML"
            ),
            reply_markup=trends_page_kb(items, page=0)
        )
    except Exception:
        await c.message.delete()
        await c.message.answer_photo(
            photo=IMAGES["trends"],
            caption=caption_ready,
            parse_mode="HTML",
            reply_markup=trends_page_kb(items, page=0)
        )






@dp.callback_query(F.data.startswith("trend:page:"))
async def cb_trends_page(c: CallbackQuery, state: FSMContext):
    page = int(c.data.split(":")[-1])
    items = (SEARCH_CACHE.get(c.from_user.id) or {}).get("trends", [])
    if not items:
        await c.answer("–¢—Ä–µ–Ω–¥—ã —É—Å—Ç–∞—Ä–µ–ª–∏, –æ–±–Ω–æ–≤–∏—Ç–µ.", show_alert=False)
        return

    caption = RU["trends_title"]
    try:
        await c.message.edit_media(
            InputMediaPhoto(
                media=IMAGES["trends"],
                caption=caption,
                parse_mode="HTML"
            ),
            reply_markup=trends_page_kb(items, page=page)
        )
    except Exception:
        await c.message.delete()
        await c.message.answer_photo(
            photo=IMAGES["trends"],
            caption=caption,
            parse_mode="HTML",
            reply_markup=trends_page_kb(items, page=page)
        )

# ---- –ù–æ–≤—ã–π –ø–æ–∏—Å–∫ ----
# ---- –ù–æ–≤—ã–π –ø–æ–∏—Å–∫ ----
@dp.callback_query(F.data == "search:new")
async def cb_search_new(c: CallbackQuery, state: FSMContext):
    if not await ensure_subscribed(c, state):
        return
    await state.set_state(SearchFSM.choose_mode)

    caption = RU["search_enter_mode"]
    try:
        # –ø—Ä–æ–±—É–µ–º –∑–∞–º–µ–Ω–∏—Ç—å –Ω–∞ –∫–∞—Ä—Ç–∏–Ω–∫—É —Å —Ç–µ–∫—Å—Ç–æ–º
        await c.message.edit_media(
            InputMediaPhoto(
                media=IMAGES["search"],
                caption=caption,
                parse_mode="HTML"
            ),
            reply_markup=search_mode_kb()
        )
    except Exception:
        try:
            # –µ—Å–ª–∏ –±—ã–ª–æ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
            await c.message.edit_text(caption, reply_markup=search_mode_kb())
        except Exception:
            # –µ—Å–ª–∏ —Å–æ–≤—Å–µ–º –Ω–µ –ø–æ–ª—É—á–∏–ª–æ—Å—å ‚Äî —É–¥–∞–ª—è–µ–º –∏ —à–ª—ë–º –Ω–æ–≤–æ–µ
            await c.message.delete()
            await c.message.answer_photo(
                photo=IMAGES["search"],
                caption=caption,
                parse_mode="HTML",
                reply_markup=search_mode_kb()
            )


@dp.callback_query(SearchFSM.choose_mode, F.data.startswith("search:mode:"))
async def cb_search_mode(c: CallbackQuery, state: FSMContext):
    mode = c.data.split(":")[-1]  # any/free/paid
    await state.update_data(mode=mode)
    await state.set_state(SearchFSM.waiting_query)

    caption = RU["search_enter_query"]
    try:
        await c.message.edit_media(
            InputMediaPhoto(
                media=IMAGES["search"],
                caption=caption,
                parse_mode="HTML"
            ),
            reply_markup=back_kb(c.from_user.id, "search:menu")
        )
    except Exception:
        try:
            await c.message.edit_text(caption, reply_markup=back_kb(c.from_user.id, "search:menu"))
        except Exception:
            await c.message.delete()
            await c.message.answer_photo(
                photo=IMAGES["search"],
                caption=caption,
                parse_mode="HTML",
                reply_markup=back_kb(c.from_user.id, "search:menu")
            )


@dp.message(StateFilter(SearchFSM.waiting_query))
async def cb_search_query(m: Message, state: FSMContext):
    if not await ensure_subscribed(m, state):
        return

    data = await state.get_data()
    mode = data.get("mode", "any")
    q = (m.text or "").strip()
    if not q:
        await m.answer("–ü—É—Å—Ç–æ–π –∑–∞–ø—Ä–æ—Å. –í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –ø–æ–∏—Å–∫–∞.")
        return

    msg = await m.answer(RU["search_loading"])

    results = await api_search(q, mode=mode, page=1, max_items=20)
    if not results:
        await msg.edit_text(RU["search_no_results"].format(q=q), reply_markup=search_menu_kb(m.from_user.id))
        await state.clear()
        return

    SEARCH_CACHE[m.from_user.id] = {"results": results, "index": 0, "query": q, "mode": mode}
    await state.set_state(SearchFSM.showing_results)

    item = results[0]
    caption = format_script_caption(item)
    img = extract_image_url(item)

    try:
        await msg.delete()
        if img and isinstance(img, str) and img.startswith("http"):
            sent = await m.answer_photo(
                photo=img,
                caption=caption,
                parse_mode=ParseMode.HTML,
                reply_markup=search_nav_kb(0, len(results))
            )
            SEARCH_CACHE[m.from_user.id]["message_id"] = sent.message_id
        else:
            sent = await m.answer(
                caption,
                parse_mode=ParseMode.HTML,
                reply_markup=search_nav_kb(0, len(results))
            )
            SEARCH_CACHE[m.from_user.id]["message_id"] = sent.message_id
    except Exception:
        await msg.edit_text(
            caption,
            parse_mode=ParseMode.HTML,
            reply_markup=search_nav_kb(0, len(results))
        )
        SEARCH_CACHE[m.from_user.id]["message_id"] = msg.message_id





def is_on_cooldown(user_id: int) -> int:
    """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –æ—Å—Ç–∞–≤—à–∏–µ—Å—è —Å–µ–∫—É–Ω–¥—ã –∫–¥, –µ—Å–ª–∏ –µ—Å—Ç—å, –∏–Ω–∞—á–µ 0."""
    now = datetime.now(timezone.utc)
    last = LAST_SWIPE_AT.get(user_id)
    if last:
        delta = now - last
        remain = SWIPE_COOLDOWN - int(delta.total_seconds())
        if remain > 0:
            return remain
    return 0

def touch_cooldown(user_id: int):
    LAST_SWIPE_AT[user_id] = datetime.now(timezone.utc)

async def update_search_card(c: CallbackQuery, new_index: int):
    cache = SEARCH_CACHE.get(c.from_user.id) or {}
    results = cache.get("results", [])
    if not results:
        await c.answer("–†–µ–∑—É–ª—å—Ç–∞—Ç—ã —É—Å—Ç–∞—Ä–µ–ª–∏. –ó–∞–ø—É—Å—Ç–∏—Ç–µ –ø–æ–∏—Å–∫ –∑–∞–Ω–æ–≤–æ.", show_alert=False)
        return

    new_index = max(0, min(new_index, len(results) - 1))
    item = results[new_index]
    caption = format_script_caption(item)
    img = extract_image_url(item)

    msg_id = cache.get("message_id")
    chat_id = c.message.chat.id if c.message else None

    if not msg_id or not chat_id:
        await c.answer("–°–æ–æ–±—â–µ–Ω–∏–µ —É—Å—Ç–∞—Ä–µ–ª–æ, –Ω–∞—á–Ω–∏—Ç–µ –ø–æ–∏—Å–∫ –∑–∞–Ω–æ–≤–æ.", show_alert=True)
        return

    try:
        if img:
            media = InputMediaPhoto(media=img, caption=caption, parse_mode=ParseMode.HTML)
            await bot.edit_message_media(chat_id=chat_id, message_id=msg_id, media=media)
        else:
            # –µ—Å–ª–∏ –∫–∞—Ä—Ç–∏–Ω–∫–∏ –Ω–µ—Ç, –º–µ–Ω—è–µ–º —Ç–æ–ª—å–∫–æ —Ç–µ–∫—Å—Ç
            await bot.edit_message_caption(chat_id=chat_id, message_id=msg_id, caption=caption, parse_mode=ParseMode.HTML)
        await bot.edit_message_reply_markup(chat_id=chat_id, message_id=msg_id, reply_markup=search_nav_kb(new_index, len(results)))
    except Exception as e:
        # –Ω–µ —à–ª—ë–º –Ω–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ ‚Äî –ø—Ä–æ—Å—Ç–æ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–∞–µ–º
        await c.answer("–ù–µ —É–¥–∞–ª–æ—Å—å –æ–±–Ω–æ–≤–∏—Ç—å –∫–∞—Ä—Ç–æ—á–∫—É", show_alert=False)

    cache["index"] = new_index
    SEARCH_CACHE[c.from_user.id] = cache

@dp.callback_query(SearchFSM.showing_results, F.data.in_({"search:first", "search:prev", "search:next", "search:last"}))
async def cb_search_nav(c: CallbackQuery, state: FSMContext):
    remain = is_on_cooldown(c.from_user.id)
    if remain > 0:
        await c.answer(RU["swipe_on_cooldown"].format(sec=remain), show_alert=False)
        return

    cache = SEARCH_CACHE.get(c.from_user.id) or {}
    idx = int(cache.get("index", 0))
    results = cache.get("results", [])
    if not results:
        await c.answer("–†–µ–∑—É–ª—å—Ç–∞—Ç—ã —É—Å—Ç–∞—Ä–µ–ª–∏. –ó–∞–ø—É—Å—Ç–∏—Ç–µ –ø–æ–∏—Å–∫ –∑–∞–Ω–æ–≤–æ.", show_alert=False)
        return

    if c.data == "search:first":
        new_idx = 0
    elif c.data == "search:prev":
        new_idx = max(0, idx - 1)
    elif c.data == "search:next":
        new_idx = min(len(results) - 1, idx + 1)
    else:
        new_idx = len(results) - 1

    await update_search_card(c, new_idx)
    touch_cooldown(c.from_user.id)
    await c.answer()


@dp.callback_query(F.data == "noop")
async def cb_noop(c: CallbackQuery):
    try:
        await c.answer()
    except Exception:
        pass

# --------------- RUN -----------------
async def main():
    print("Bot started as @" + BOT_USERNAME)
    await set_commands(bot)
    await dp.start_polling(bot, allowed_updates=dp.resolve_used_update_types())




if __name__ == "__main__":
    from db import init_db

    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–∞–∑—ã (—Å–æ–∑–¥–∞–Ω–∏–µ —Ç–∞–±–ª–∏—Ü, –µ—Å–ª–∏ –∏—Ö –Ω–µ—Ç)
    init_db()

    try:
        asyncio.run(main())
    except (KeyboardInterrupt, SystemExit):
        print("Bot stopped")
